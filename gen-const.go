package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/constant"
	"go/format"
	"go/token"
	"go/types"
	"golang.org/x/tools/go/packages"
	"log"
	"os"
	"path/filepath"
	"strings"
)

var (
	typeNames  = flag.String("type", "", "以逗号分隔的类型名列表；必须设置")
	output     = flag.String("output", "", "输出文件名；默认 srcdir/<type>_constant.go")
	trimprefix = flag.String("trimprefix", "", "从生成的常量名称中删除`前缀`")
	buildTags  = flag.String("tags", "", "要应用的生成标记的逗号分隔列表")
)

// Usage 是FLAGS包的替换使用函数。
func Usage() {
	fmt.Fprintf(os.Stderr, "gen-const 的使用方式:\n")
	fmt.Fprintf(os.Stderr, "\tgen-const [flags] -type T [directory]\n")
	fmt.Fprintf(os.Stderr, "\tgen-const [flags] -type T files... # 必须是单个包\n")
	fmt.Fprintf(os.Stderr, "Flags:\n")
	flag.PrintDefaults()
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("gen-const: ")
	flag.Usage = Usage
	flag.Parse()
	if len(*typeNames) == 0 {
		flag.Usage()
		os.Exit(2)
	}

	// 判断输出
	if *output == "" {
		*output = strings.ToLower(*typeNames) + "_constant.go"
	}

	args := flag.Args()
	if len(args) == 0 {
		args = []string{"."}
	}

	var dir string
	g := Generator{
		trimPrefix: *trimprefix,
	}

	if len(args) == 1 && isDirectory(args[0]) {
		dir = args[0]
	} else {
		dir = filepath.Dir(args[0])
	}

	var tags []string
	if len(*buildTags) > 0 {
		tags = strings.Split(*buildTags, ",")
	}

	g.parsePackage(args, tags)

	// Print the header and package clause.
	g.WriteString(fmt.Sprintf("// Code generated by \"gen-const %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " ")))
	g.WriteString("\n")
	g.WriteF("package %s\n\n", g.pkg.name)
	g.WriteString("import \"strconv\"\n")
	g.WriteString("\n")

	// Run generate for each type.
	for _, typeName := range strings.Split(*typeNames, ",") {
		g.generate(typeName)
	}

	src := g.format()

	// Write to file.
	outputName := *output
	if outputName == "" {
		baseName := *output
		outputName = filepath.Join(dir, strings.ToLower(baseName))
	}
	err := os.WriteFile(outputName, src, 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

func (g *Generator) format() []byte {
	src, err := format.Source(g.Bytes())
	if err != nil {
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.Bytes()
	}
	return src
}

func (g *Generator) generate(typeName string) {
	values := make([]Value, 0, 100)
	structTypeName := typeName + "Type"
	for _, file := range g.pkg.files {
		file.typeName = typeName
		file.values = nil
		if file.file != nil {
			ast.Inspect(file.file, file.genDecl)
			values = append(values, file.values...)
		}
	}

	if len(values) == 0 {
		log.Fatalf("no values defined for type %s", typeName)
	}

	g.WriteF("type %s struct {\n", structTypeName)
	g.WriteString("\tintVal int `json:\"intVal\"`\n")
	g.WriteString("\tstrVal string `json:\"strVal\"`\n")
	g.WriteString("}\n")
	g.WriteString("\n")

	g.WriteF("func (receiver *%s)GetIntVal() int {\n", structTypeName)
	g.WriteString("\treturn receiver.intVal\n")
	g.WriteString("}\n")
	g.WriteString("\n")

	g.WriteF("func (receiver *%s)GetStrVal() string {\n", structTypeName)
	g.WriteString("\treturn receiver.strVal\n")
	g.WriteString("}\n")
	g.WriteString("\n")

	g.WriteF("func %sFunc(intVal int, strVal string) *%s {\n", typeName, structTypeName)
	g.WriteF("\treturn &%s{\n", structTypeName)
	g.WriteF("\t\tintVal: %s,\n", "intVal")
	g.WriteF("\t\tstrVal: %s,\n", "strVal")
	g.WriteString("\t}\n")
	g.WriteString("}\n")
	g.WriteString("\n")

	g.WriteF("func (receiver *%s) String() string {\n", structTypeName)
	g.WriteF("\treturn \"%s(%s: \"+ %s +\", %s: \"+ %s +\")\"\n", structTypeName, "intVal", "strconv.Itoa(receiver.intVal)", "strVal", "receiver.strVal")
	g.WriteString("}\n")
	g.WriteString("\n")

	g.WriteString("var (\n")
	for _, v := range values {
		originalName := v.originalName
		if len(originalName) > 0 {
			v := []byte(originalName)
			x := string(v[0])
			t := []byte(strings.ToUpper(x))
			v[0] = t[0]
			originalName = string(v)
		}
		g.WriteF("\t%s%s = %s(%d, \"%s\")\n", originalName, typeName, typeName+"Func", v.value, v.name)
	}
	g.WriteString(")\n")
}

func (g *Generator) WriteF(format string, a ...any) {
	g.WriteString(fmt.Sprintf(format, a...))
}

func (g *Generator) parsePackage(patterns []string, tags []string) {
	cfg := &packages.Config{
		Mode:       packages.NeedName | packages.NeedTypes | packages.NeedTypesInfo | packages.NeedSyntax,
		Tests:      false,
		BuildFlags: []string{fmt.Sprintf("-tags=%s", strings.Join(tags, " "))},
	}
	pkgs, err := packages.Load(cfg, patterns...)
	if err != nil {
		log.Fatal(err)
	}
	if len(pkgs) != 1 {
		log.Fatalf("error: %d packages matching %v", len(pkgs), strings.Join(patterns, " "))
	}
	g.addPackage(pkgs[0])
}

func (g *Generator) addPackage(pkg *packages.Package) {
	g.pkg = &Package{
		name:  pkg.Name,
		defs:  pkg.TypesInfo.Defs,
		files: make([]*File, len(pkg.Syntax)),
	}

	for i, file := range pkg.Syntax {
		g.pkg.files[i] = &File{
			file:        file,
			pkg:         g.pkg,
			trimPrefix:  g.trimPrefix,
			lineComment: true,
		}
	}
}

type Generator struct {
	bytes.Buffer
	pkg        *Package
	trimPrefix string
}

type Package struct {
	name  string
	defs  map[*ast.Ident]types.Object
	files []*File
}

type File struct {
	pkg      *Package
	file     *ast.File
	typeName string
	values   []Value

	trimPrefix  string
	lineComment bool
}

func (f *File) genDecl(node ast.Node) bool {
	decl, ok := node.(*ast.GenDecl)
	if !ok || decl.Tok != token.CONST {
		return true
	}
	typ := ""
	for _, spec := range decl.Specs {
		vspec := spec.(*ast.ValueSpec) // Guaranteed to succeed as this is CONST.
		if vspec.Type == nil && len(vspec.Values) > 0 {

			typ = ""

			ce, ok := vspec.Values[0].(*ast.CallExpr)
			if !ok {
				continue
			}
			id, ok := ce.Fun.(*ast.Ident)
			if !ok {
				continue
			}
			typ = id.Name
		}
		if vspec.Type != nil {
			ident, ok := vspec.Type.(*ast.Ident)
			if !ok {
				continue
			}
			typ = ident.Name
		}
		if typ != f.typeName {
			continue
		}

		for _, name := range vspec.Names {
			if name.Name == "_" {
				continue
			}

			obj, ok := f.pkg.defs[name]
			if !ok {
				log.Fatalf("no value for constant %s", name)
			}
			info := obj.Type().Underlying().(*types.Basic).Info()
			if info&types.IsInteger == 0 {
				log.Fatalf("can't handle non-integer constant type %s", typ)
			}
			value := obj.(*types.Const).Val() // Guaranteed to succeed as this is CONST.
			if value.Kind() != constant.Int {
				log.Fatalf("can't happen: constant is not an integer %s", name)
			}
			i64, isInt := constant.Int64Val(value)
			u64, isUint := constant.Uint64Val(value)
			if !isInt && !isUint {
				log.Fatalf("internal error: value of %s is not an integer: %s", name, value.String())
			}
			if !isInt {
				u64 = uint64(i64)
			}
			v := Value{
				originalName: name.Name,
				value:        u64,
				signed:       info&types.IsUnsigned == 0,
				str:          value.String(),
			}
			if c := vspec.Comment; f.lineComment && c != nil && len(c.List) == 1 {
				v.name = strings.TrimSpace(c.Text())
			} else {
				v.name = strings.TrimPrefix(v.originalName, f.trimPrefix)
			}
			f.values = append(f.values, v)
		}
	}
	return false
}

type Value struct {
	originalName string
	name         string
	value        uint64
	signed       bool
	str          string
}

func (v *Value) String() string {
	return v.str
}

func isDirectory(name string) bool {
	info, err := os.Stat(name)
	if err != nil {
		log.Fatal(err)
	}
	return info.IsDir()
}
